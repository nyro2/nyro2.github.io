---
layout: default
title: SICP
---
### SICP 001
#### 問題1.1  
　だるいので略。

#### 問題1.2  
```
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
```
　字下げが見づらい。対処が必要やな……。  

#### 問題1.3  
```
(define (add-2big-square x y z)
    (cond ((and (< x y) (< x z)) (+ (* y y) (* z z)))
        ((and (< y x) (< y z)) (+ (* x x) (* z z)))
        (else (+ (* x x) (* y y)))))
```
　関数名にセンスがなさすぎる。  
　自乗と自乗の和に関しては本文中でやってたように別関数化した方が趣旨に沿っている。  

#### 問題1.4  
　演算子として合成式(if (> b 0) + -)が配置されている。  
　この時、引数bが正であれば特殊形式ifの述語が真となり、帰結部の値+が返る。  
　引数bが負であれば述語が偽となり、代替部の値-が返る。  
　結果として、この手続きは引数aに引数bの絶対値を加算する。  

#### 問題1.5  
　作用的順序の場合、まずパラメタpが評価される。しかしpの定義は循環しているので、評価は終わらず、無限にループしてしまう。  
　正規順序の場合、まず演算子testが評価される。ここでx = 0であるため、返り値は0となる。必要となるまで値が評価されないという特徴により、pの循環定義は問題にならない。  

#### 問題1.6  
　ifは特殊形式なので述語が真なら代替部は評価せずに帰結部を返すことが可能だが、new-ifは特殊形式ではないので、帰結部と代替部を両方とも評価してからcondで分岐を行う。この平方根を求める手続きは再帰的な構造を持つため、代替部の評価はいつまで経っても終わらず、無限ループとなる。  

#### 問題1.7  
　許容できる誤差として0.001という値を用いているため、この値に対して充分に大きな数値でない限り、計算の精度が悪化してしまう。また、極端に大きな数値に関しては、無限ループが発生する。理由は詳しく調べておらなんだ……。  
　改善コードは以下。独力で書けなかったので調べてアレした。敗北。  
```
(define (good-enough? guess x)
  (< (abs (- 1.0 (/ guess (improve guess x)))) 0.001))
```
